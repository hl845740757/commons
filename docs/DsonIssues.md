# Dson设计中的一些反思

Q：Dson是什么？  
A：Dson是JSON和Bson的改进，其中'D'的含义是'Data'的意思，Dson是自解释的数据对象。

Q：为什么创建Dson？  
A：在设计Dson之前，我也设计了序列化组件，也可以很好的工作；但后来在进行一些扩展的时候发现很难受，代码写得很不顺，思来想去，
发现是因为之前的Reader和Writer干的事情太多了，既在处理二进制的编码问题，又在处理业务层的对象编解码需求，如：读写替换、随机读。

简单说就是：**在二进制与Object之间少了一层中间层描述**。  
创建Dson之后，读对象需要两个Reader，写对象需要两个Writer，但代码变得清晰了，扩展性也更好了。

Q：Dson的主要目的？  
A：现在的Dson有3个主要目的：

1. 精确的序列化
2. 可转换为其它数据格式的中间层数据结构，使得业务只需要编码为Dson，而不需要写更多的Codec
3. 配置文件 -- 最初仅仅是期望能输出为可读的文本，可从文本中读取

<br>

Q：为什么要像Json一样，顶层必须是object或array，而不能直接写内容？  
A：这与引用的支持有关，引用可以很好的实现配置复用和减少嵌套；而被引用的对象最好都放置在顶层，这可以降低复杂度，所以我们的顶层上下文其实是一个数组。

---
<br>

Q：为什么数字的解析默认只有double？  
A：**确定性的解析结果很重要**。浮点数可能恰好是一个整数，一个值，一会儿解析成浮点数，一会儿解析成整数，会让解析后的类型变得不确定，从而导致应用程序出现错误。

eg：` {x: 1, y: 1.0, z: 1.0 } `，这段输入难道解析为1个int，2个double吗？

Q：为什么 NaN，Infinity 这些特殊数值也要加类型标记？  
A：如果只是要求字符串在处理其它类型的特殊值时加引号，扩展特殊值时将产生兼容性问题；另外，要处理的特殊值过多时，将难以快速确定是否要加引号（要记忆的过多），从而可能导致兼容性问题。
每一类的特殊输入时都应该声明类型，才能保持解析的精确性和保证良好的扩展性，也可以减轻字符串的解析压力和书写难度。

Q：为什么科学计数法也要求加类型了？  
A：有两个原因：

1. 科学计数法的匹配效率较低
2. 使用科学计数法的频次不高 -- 这是一个假设

要求科学计数法也加类型，可以很好的降低解析的复杂度，和提高解析效率；
Dson的全局指导是：**一旦你想以某种特殊形式输入一个值，都应该显式声明这个值的类型**。

Q：为什么浮点数不支持16进制和2进制？只有number类型的脚本语言怎么办？  
A：浮点数的16进制格式并不容易书写，可读性也较低 -- 不过16进制可以有更好的精度。  
对于只有number类型的脚本语言，如果需要使用16进制输入整数，也请在文本中声明为int32或int64类型。

PS: dson的底层实现并未限制使用16进制，如果你能正确书写，且语言本身支持的话，是可以正确解析的。

Q：Dson打印的大量的@i、@L、@f能不能省掉？  
A：默认情况下int32/int64/float都是需要打印类型以确保精确解析的；但在实现自己的codec的时候，如果存在对应的Class，通常可以省去类型信息。

---
<br>

Q：为何修改了Dson1中的行首设计？  
A：在真实应用Dson的时候发现，我更喜欢无行首的宽松模式，因为行首大多数时候是无意义的负担 ——
写久了宽松模式以后，就想让宽松模式也支持复杂的文本块。  
行首的功能主要是行的拆分和合并，而且只用于字符串，因此我想到可以只让文本块进入特殊的输入模式，这样就省去其它时候的行首输入。  
考虑到大家对于`"""`已有认知，因此设计了两种文本块模式。`"""`保持为大家常见的简单文本块，`@"""`为Dson专属文本块，每一行分为行首和内容。

Q：为什么三引号`"""`文本块根据开始的引号确定缩进？  
A：我在选择方案前测试了Java和C#的文本块，发现或多或少都有点不科学，比如：

1. C#通过末尾的三引号来确定缩进的，这种方式虽然能解决缩进的问题，但并不符合正常人的思维。
    1. 因为正常手写文本肯定是从上往下写，因此是**先确定对齐，再开始书写**；另外，在书写的过程中需要考虑与前文的缩进。
    2. 通过末尾三引号确定缩进，还存在另一个问题：解析的复杂度高，需要较大的缓冲区。
    3. 因为扫描器必须先确定末尾三引号的位置，确定缩进之后，再回到文本开始处，这可能需要较大的缓存空间，性能不太好。
2. Java取所有行的最小缩进来确缩进，这种方式看似智能，也存在一些明显问题。
    1. 与C#相同的问题是：解析的复杂度高，需要较大的缓冲区。因为只有扫描所有行之后才可确定缩进。
    2. 缩进是动态的，修改任意一行都可能破坏缩进，这不符合我们的一般期望。

所以，第一行确定缩进更为合适，也就是说以开始的三引号来确定缩进更为合适。这要求我们文本段必须独立成块，有点像markdown中的代码块。

---
<br>

Q：为什么日期时间（DateTime）不直接支持 ISO8601格式的字符串？  
A：表面上看，支持DateTime似乎很简单，实则不然。在最初设计Dson的时候，是考虑过内置一个时间格式的，但尝试后放弃了，有这么些原因：

1. ISO8601时间格式的可能性太多，不是简单的两三种情况 -- ISO8061的规范可能都超过了Dson的规范。
2. 我认为ISO8601时间格式的可读性并不好。
    1. 经常缺胳膊少腿，长度不统一，尤其是秒之后的部分，我还要去数小数点后有几位？？？。
    2. 字符串太长，T和± 符号的加入导致可读性下降。
3. 时间的表达方式与存储格式和业务很是相关，一旦要支持就需要考虑业务需求，比如：某个部分是否可不输入，考虑这些会引入额外的复杂度，且难以让所有人满意。

基于上面存在的问题，在提供新的时间结构体的时候，加强了约束，不支持ISO8601那种随意的写法，我们将时间的各个部分拆分输入，
且每个部分的格式很是限定。  
你可能觉得dson的时间输入有点繁琐，但我们使用日期时间的频次并不高，严格的格式和可选的输入是有益的。

PS：

1. 一个很好的编程指导是：**简单很重要，而严格的输入能保持简单性**。
2. Dson最终选择了支持时间，不是因为日期时间是必须的，而是用户封装日期时间将在语法上遇见不便。
3. ISO8601的复杂度来源于要将大量的信息集中显示。
4. 时区最终支持了多种输入方式，因为在多数情况下，我们都只精确到小时，因此允许简写。

<br>

Q：为什么默认不解析的引用的情况下，还提供了引用数据结构？  
A：引用这个东西逃不了。用于单纯的配置文件时，能引用公共的配置是很方便的；用于大量对象管理的时候，引用更是少不了。
作者是游戏开发者，经常利用编辑器导出文件，这些文件中包含了大量的对象，而且是存在引用关系的。  
但是！什么时候解析引用，以及如何解析引用是应用层决定的，才能保持好的扩展。因此，Dson只设计数据结构，而默认不解析。

Q：为什么 ptr 不是元组？  
A：因为我们提供的引用数据结构较为复杂，导致存在较多的可选项，不像 ei、eL、es那般确定，因此不能使用固定结构的元组来进行解析。  
取而代之的是，我们提供了 @ptr localId
这样的支持，因为大多数情况下，用户都是引用文件内的内容，因此支持单个值的快捷写法即可满足日常需求。  
另外，namespace + localId 这种通常只有程序使用Dson的情况下才会出现，因此不需要提供简单的书写方式。  
另外，在我们支持了单值和结构体方式的情况下，再去支持第三种方式的话是不明智的，这样用户的使用复杂度会攀升。

Q:为什么namespace要使用缩写？  
A：我发现一个规律：**单词字母数 >= 9 时错误率陡升**
。敲击namespace的过程中，经常出现字母顺序错误，我经常拼写错误的另一个单词是component，经常会写为componnet，仔细一数，也是9个字母。
在dson所有的预设属性名中，只有namespace是9个字符，于是我将namespace替换为简写ns，书写流畅度明显提升。

Q :为什么要设计轻量指针(lptr)？  
A：这个功能来源于**序列化对象图**压缩空间的需要。在我们序列化对象图时，需要将对象的引用转换为索引(localId)，
而这个localId只需要是int32/int64类型即可， 使用字符串会大幅度增加包体大小，且降低序列化序列化速度。  
我曾经想过将ref结构中的localId修改为int32/int64，但这可能导致ref结构不能适用所有场景，再三思索下，我决定添加一个特化的类型，以优化特定场景下的开销。
我们仍保留`namespace`为字符串类型，将其限定为int32/int64固然可以节省开销，但其适用范围太窄。

<br>

Q：二进制(bin)的编码选择？  
A：在最开始的时候选择的是Base64编码，但Base64的可读性很差，而设计DSON文本格式的目的就是为了可读和可操作，因此Base64不是个好选择；
在二进制(01)和16进制的选择中，我们选择了16进制，因为16进制需要的字符更少，且表达力足够。  
PS：Dson是有二进制存储格式的，因此在传输效率有要求的场合，使用二进制格式传输更为高效。

<br>

Q：变量可以很好的支持配置复用，为什么不像别的配置文件那样支持*变量*？  
A：变量是把双刃剑。引入变量实际上就是让配置文件变为脚本语言，这会让文本的解析变得十分复杂；另外，配置文件去干编程语言干的事情，我认为不太明智，这会限制语言层的扩展。

<br>

Q：ObjectReader中的*SetKeyItr*方法的作用？  
A: 这个方法是为Codec服务的，Dson中数据的顺序可能和期望的顺序不一致，允许指定Key的迭代顺序，可以以较低的成本解决字段不匹配的问题。

<br>

Q：为什么之前不支持换行符代替空格分割label和元素，而现在又支持了呢？  
A：之前不支持是从程序的角度考虑的，这可以保证正确性和缩进格式无关。但后来写了一段时间的dson后，
发现写@ss长文本的时候，通常习惯换行开始写（有利于排版），但容易忘记@ss后的空格，便意识到这个设计似乎有点反人类。

**所见即所得是人的思维定势**，人习惯于看见的是什么样的，就认为是什么样的；*眼睛认为是分开的，就应该是分开的*。
如果程序的规则不符合人的思维定势，就很难以使用；所以程序的终极目标之一就是：所见即所得。

*换行是明显的分隔符*，如果换行起不到换行的作用，也起不到分隔的作用，那就是很糟糕的规则；
空格只有用在可见字符之间是很明显的分隔符，用在行尾是看不见的，因此不应该使用行尾空格制定规范 --
我就不喜欢Markdown这一点。  
所以，我修改了token的解析规则，换行符可以用于分隔label和对应的元素。

PS: 图形程序和文本程序，尤其要注意“所见即所得”这条指导。

<br>

Q：为什么header不写在对象外面？写在外面似乎格式更加一致？  
A：用户手写倒是方便，但程序读写就很麻烦了。 header和data连续写入，object的内容更加内聚，截取数据更加容易，readr和writer也更容易实现。
一个很好的类比是网络数据包的封包，网络数据包一般分为 header和data 两部分，但整体是一个数据包，而不是两个独立的部分。

<br>

Q：行首的选择？  
A：选择行首需要满足以下条件：

1. 足够显眼，能强调差异。
2. 足够平淡，不能干扰阅读。
3. 书写方便。
4. 最好还能有一定的语义暗示(表意性)。

三个及以上字符不考虑，输入麻烦，占排版也较多；两个字符是可以的，但后来发现单个字符输入最方便，也更方便tab缩进。  
数字和字母不能做行首，很容易干扰阅读，只能选择不具含义的字符。

---

## Codec

Q：为什么Codec模块从Dson项目中移除了？  
A：Dson和Dson-Codec本就是从我的Commons模块中迁移出来的，Dson做到无依赖是比较容易的，但Codec与Commons的基础组件之间有较多的依赖，
Codec放在Dson中会导致复杂的包依赖，既不利于我维护，也不利于他人阅读。


<br>

Q: Header的长度也使用Fixed32编码，开销不会太大吗？  
A：这个问题较难解决，因为对其长度单独编码，比如Fixed16，又会增加额外的复杂度，我不想引入该复杂度。
那怎么优化序列化后的大小呢？ 在实际的Codec应用中，我们会根据对象的声明类型和实际类型判断是否需要写入Header，
这可以减少大量的Header写入，从而使得压缩Header的结构变得不那么重要。
